//Librerías conexion internet, petición HTTP
#include <WiFi.h>
#include <HTTPClient.h>
//librerías pantalla TFT_ISP
#include <TFT_eSPI.h>
#include <SPI.h>
//incluir archivos de imagenes para mostrar en la pantalla
#include "ImgWarn.h"
#include "LoadWifi.h"
#include "NoWifi.h"
#include "Load.h"
#include "imgError.h"
#include "imgMant.h"
#include "ok.h"
#include "hub.h"
#include "search.h"
#include "Notfound.h"
#include "TryAgain.h"
#include "beer.h"
//incluiur fuentes
#include "Free_Fonts.h"
//Incluir las librerias para la lectura de NFC
#include <Wire.h>
#include <PN532_I2C.h>
#include <PN532.h>
#include <NfcAdapter.h>

//Variables para conexion con el servidor
const char *ssid = "NETLIFE-Andres Balarezo";  //NETLIFE-Andres Balarezo, ROYAL HUB
const char *password = "1003410675";           //1003410675, 11_royalhub2023
const char *apiUrl = "http://192.168.100.43:8000/api/maquinas/beer/activar?id_maquina=66eed425-3d7f-4d12-899d-867b2c9c4308&estado="; //66eed425-3d7f-4d12-899d-867b2c9c4308, server susy 636d69bd-6931-4025-b2f3-f76fb42b8bc7
const char *apiUrlMant = "http://192.168.100.43:8000/api/maquinas/beer/activar?id_maquina=66eed425-3d7f-4d12-899d-867b2c9c4308&estado=2";
const char *apiUrlSensor = "http://192.168.100.43:8000/api/sensor/beer/escanear?id_maquina=66eed425-3d7f-4d12-899d-867b2c9c4308&codigo_sensor=";
const char *apiUrlVolumen = "http://192.168.100.43:8000/api/sensor/maquina/venta?id_maquina=66eed425-3d7f-4d12-899d-867b2c9c4308&id_beer=";

//objeto para controlar la librería TFT_eSPI
TFT_eSPI tft = TFT_eSPI();

//objeto de la libreria NFC
PN532_I2C pn532i2c(Wire);
PN532 nfc(pn532i2c);

//Medición de tiempo lectura sensor nfc
const unsigned long timeInterval = 30000UL;

//Medición de tiempo espera conexion internet (1 minuto de espera)
const unsigned long timewifi = 60000UL;

//Medición de tiempo espera Peticion GET APIUrl (2 minutos de espera)
const unsigned long timeApiurl = 120000UL;

//Medición de tiempo espera Peticion GET APIUrlSensor (10 segundos de espera)
const unsigned long timeApiurlSensor = 10000UL;

//Medición de tiempo espera Peticion GET APIUrlVolumen (10 segundos de espera)
const unsigned long timeApiurlVolumen = 10000UL;

//Puerto de salida para control rele
const int control = 14;

//variable contador error de lectura de la pulsera
int error_lectura;

// Variables control flujometro
const int sensorPin = 33;
const unsigned long measureInterval = 500UL;
volatile int pulseConter;
const float factorK = 7.663;  //8.363

//Variables calculo volumen
float volumen = 0;
unsigned long t0 = 0;  //millis() del bucle anterior
unsigned long dt = 0;

// variables para el control del tiempo de espera para desactivar la máquina
unsigned long previousMillis = 0;            // Almacena el tiempo anterior
const unsigned long interval = 5000UL;       // Intervalo de tiempo en milisegundos (5 segundos)
unsigned long tiempoInicioTemporizador = 0;  // Variable para almacenar el tiempo de inicio del temporizador

//Función para conectar al WiFi
void ConnectWiFi() {
  //Inicializa el objeto wifi y conecta a internet
  WiFi.mode(WIFI_STA);
  WiFi.begin(ssid, password);
  int x = 30;
  tft.drawString("Connecting to WIFI", 10, 25);
  //  Serial.println("Connecting to WIFI!!");
  unsigned long startTime = millis();
  //en caso de falla de conexion a internet vuelve a intentar conectarse por 1 minuto
  while (WiFi.status() != WL_CONNECTED && millis() - startTime < timewifi) {
    tft.pushImage(128, 25, 64, 64, LoadWifi);
    delay(50);
    x++;
    tft.drawString(".", x, 35);
    if (x >= 220) {
      x = 30;
    }
    //Serial.println("Conectando a WiFi...");
  }
  //si pasado el minuto no logro conectarse entra a un loop infinito mostrando un mensaje de error
  if (millis() - startTime >= timewifi) {
    tft.fillScreen(TFT_BLACK);
    //    tft.drawString("Error conexion", 10, 45);
    //exit(0);
    while (true) {
      tft.pushImage(128, 25, 64, 64, NoWifi);
      tft.drawString("Error conexion", 65, 95, 4);
    }
  }
  //tft.fillScreen(TFT_BLACK);
  tft.drawString("Conectado a la red WiFi", 10, 45);
  //  Serial.println("Conectado a la red WiFi");
}

//Función para enviar peticiones para conectarse al servidor
//se tiene que enviar el id_maquina y el estado
int ConnectApiUrl(uint32_t versiondata) {

  //acatualización de estado si la lectura del sensor NFC fue satisafactoria
  String estado;
  if (!versiondata ) {
    estado = "2";
  } else {
    estado = "1";
  }

  //Concatenar la url de la API con el estado
  String urlConcatenada = apiUrl + estado;

  // Imprime la URL concatenada
  //Serial.println(urlConcatenada);
  tft.drawString(urlConcatenada, 10, 55);

  //Enviar petición HTTP Get
  HTTPClient http;
  http.begin(urlConcatenada);
  int httpCode = http.GET();

  //en caso de falla de peticion GET vuelve a intentar conectarse por 1 y 30 minuto
  unsigned long startTime = millis();
  while (httpCode != 201 && millis() - startTime < timeApiurl) {
    tft.pushImage(128, 25, 64, 64, Load);
    httpCode = http.GET();
    //Serial.println("Código de respuesta: " + String(httpCode));
    tft.drawString("R: " + String(httpCode), 10, 65);
  }

  String response = http.getString();

  //si pasado 1 y 30 mintuos no logro conectarse entra a un loop infinito mostrando un mensaje de error
  if (millis() - startTime >= timeApiurl) {
    http.end();
    tft.fillScreen(TFT_BLACK);
    //    tft.drawString("Error peticion GET", 10, 45);
    //exit(0);
    while (true) {
      tft.pushImage(128, 25, 64, 64, imgError);
      tft.drawString("Error peticion", 65, 95, 4);
      //tft.drawString("Error peticion GET ", 10, 45);
      tft.drawString(response, 10, 55);
      //Serial.println("Código de respuesta: " + String(httpCode));
      tft.drawString("R: " + String(httpCode), 10, 65);
    }
  }

  if (estado == "2") {
    http.end();
    tft.fillScreen(TFT_BLACK);
    while (true) {
      //tft.drawString("Maquina en mantenimiento", 10, 45);
      tft.pushImage(128, 25, 64, 64, imgMant);
      tft.drawString("Maquina en mantenimiento", 5, 95, 4);

    }
  }

  //Serial.println(response);
  tft.drawString(response, 10, 75);
  http.end();
  //Serial.println("Código de respuesta: " + String(httpCode));
  tft.drawString("R: " + String(httpCode), 10, 85);
  return httpCode;
}

// Funcion para imprimir la direccion de la tarjeta NFC
void imprimirValores(uint8_t uid[], uint8_t uidLength) {
  //Serial.println("Found a card!");
  for (uint8_t i = 0; i < uidLength; i++) {
    //Serial.print("");
    //Serial.print(uid[i]);
  }
  //Serial.println("");
}

//Funcion para contar los pulsos sel flujometro
void IRAM_ATTR CountPulse() {
  pulseConter++;
}

//Funcion para obtener la frecuancia del flujometro
float GetFrequency() {
  pulseConter = 0;
  unsigned long startTime = millis();  // Registra el tiempo de inicio
  while (millis() - startTime < measureInterval) {
    // Timepo de espera para contar el flujo
  }
  noInterrupts();                                    // Deshabilita las interrupciones
  unsigned long elapsedTime = millis() - startTime;  // Calcula el tiempo transcurrido
  interrupts();                                      // Habilita las interrupciones nuevamente
  return (float)pulseConter * 1000 / elapsedTime;    //return (float)pulseConter * 1000 / elapsedTime;
}

//función para obtener el volumen consumido
float getvolume(float frequency) {
  float caudal = frequency / factorK;
  t0 = millis() - dt;                                   //calculamos la variación de tiempo
  volumen = volumen + (((caudal / 60) * (t0)) / 1000);  // volumen(L)=caudal(L/s)*tiempo(s) (dt/1000)
  return volumen;
}

void setup() {

  // Declaramos el pin de control del rele con un pin de salida OUTPUT
  pinMode(control, OUTPUT);
  digitalWrite(control, HIGH);

  //Asignamos el pin del flujometro como interrupcion
  pinMode(sensorPin, INPUT_PULLUP);
  attachInterrupt(digitalPinToInterrupt(sensorPin), CountPulse, RISING);

  //Inicializamos la pantalla TFT_SPI
  tft.init();
  tft.setRotation(3);
  tft.setSwapBytes(true);
  tft.fillScreen(TFT_BLACK);

  //Inicialización del sendor NFC, si sensor no se inicializa se espera 30 seg
  //esperando incializacion, si no se envia en la peticion GET estado mantenimiento
  nfc.begin();
  uint32_t versiondata = nfc.getFirmwareVersion();
  unsigned long startTime = millis();
  while (millis() - startTime < timeInterval && versiondata == 0 ) {
    versiondata = nfc.getFirmwareVersion();
    tft.pushImage(128, 25, 64, 64, ImgWarn);
    tft.drawString("Error lectura sensor", 65, 95, 4);
  }
  tft.fillScreen(TFT_BLACK);
  tft.drawString(String(versiondata), 10, 5);
  //Serial.println("1: " + String(versiondata));
  if (versiondata != 0) {
    nfc.setPassiveActivationRetries(0xFF);
    nfc.SAMConfig();
    tft.drawString("Waiting for an ISO14443A card", 10, 15);
  }

  //Serial.println("Waiting for an ISO14443A card");
  ConnectWiFi();
  int httpCode = ConnectApiUrl(versiondata);

  unsigned long t_espera = 3000UL;
  unsigned long start = millis();
  while (millis() - start < t_espera) {
    tft.pushImage(128, 25, 64, 64, ok);
    //tft.drawString("READY", 10, 95);
  }
}

void loop() {

  tft.fillScreen(TFT_BLACK);
  tft.pushImage(110, 25, 100, 95, hub);
  tft.drawString("waiting for a card", 10, 10, 4);

  //variables para guardar la dirrecion de las tarjetas NFC
  boolean success;
  uint8_t uid[] = { 0, 0, 0, 0, 0, 0, 0 };  // Buffer to store the returned UID
  uint8_t uidLength;                        // Length of the UID (4 or 7 bytes depending on ISO14443A card type)
  //Wait for an ISO14443A type cards (Mifare, etc.). When one is found, 'uid' will be populated with the UID, and uidLength will indicate, if the uid is 4 bytes (Mifare Classic) or 7 bytes (Mifare Ultralight)
  success = nfc.readPassiveTargetID(PN532_MIFARE_ISO14443A, &uid[0], &uidLength);

  //variables banderas estado para casos de funcionamiento
  boolean ingresar = false;
  boolean estadoflujo;

  //variables cambio de estado switch casos de funcionamiento
  int estado = 0;

  //Variable para el control de l8a frecuencia del flujometro
  float frequency = 0;

  //Variable para manejar el volumen restante que recibe del servidor
  float data1 = 0;

  // Verificación de lectura de pulsera NFC
  if (success) {

    tft.fillScreen(TFT_BLACK);
    tft.pushImage(110, 25, 64, 64, search);
    //Guardar la cadena de la direccion del sensor en una variable
    //imprimirValores(uid, uidLength);
    //Enviar id_maquina y codigo_sensor al back para procesar
    String cadenaResultado = "";
    for (int i = 0; i < uidLength; i++) {
      cadenaResultado += String(uid[i]);
    }

    //Concateno el condigo de sensor a la api
    String urlConcatenada = apiUrlSensor + cadenaResultado;

    //Serial.println(urlConcatenada);
    tft.drawString(urlConcatenada, 10, 5);

    //envio la peticion get para ingresar el codigo de sensor
    HTTPClient http;
    http.begin(urlConcatenada);
    int httpCode = http.GET();

    //medicion de tiempo de espera en caso de que la peticion falle ApiUrlSensor (15 segundos de espera)
    unsigned long startTime = millis();
    while (httpCode < 0 && millis() - startTime < timeApiurlSensor ) {
      httpCode = http.GET();
      tft.drawString(String(httpCode), 10, 15);
    }

    //Si el código de respuesta es positivo obtengo la respuesta del servidor
    if (httpCode > 0) {

      //Obtego la respuesta del servidor en string
      //Serial.println("Código de respuesta: " + String(httpCode));
      tft.drawString("R: " + String(httpCode), 10, 15);
      String response = http.getString();
      http.end();
      //Serial.println(response);
      tft.drawString(response, 10, 25);

      // Separo la respuesta del string en los valores que necesito
      int index = response.indexOf(",");
      // Obtiene la subcadena antes del delimitador
      String status = response.substring(0, index);
      // Obtiene la subcadena después del delimitador
      String data = response.substring(index + 1);
      // Imprime los strings separados
      //Serial.println("1: " + status);
      tft.drawString("1: " + status, 10, 35);
      //Serial.println("2: " + data);
      tft.drawString("2: " + data, 10, 45);

      ///////////////////////////////////
      // Obtengo la respuesta del servidor y lo transformo a entero
      index = status.indexOf(":");
      // Obtiene la subcadena después del delimitador
      status = status.substring(index + 1);
      int status1 = status.toInt();
      // Imprime los strings separados
      //Serial.println(status1);
      tft.drawString(String(status1), 10, 55);
      //////////////////////////////////////
      //Serial.println("Código de respuesta: " + String(status1));

      // Switch case para entrar en cada uno de los casos de respuesta del servidor
      switch (status1) {
        case 202:
          {
            ingresar = true;
            //Activar el rele cuando se haya leido una tarjeta NFC
            digitalWrite(control, LOW);
            //Serial.println("Rele activado");
            //Serial.println(ingresar);
            tft.drawString("Rele activado : " + String(ingresar), 10, 65);

            //Separar la informacion del string data
            index = data.indexOf(":");
            data = data.substring(index + 1, data.length() - 1);
            data1 = data.toFloat();
            //Serial.println(data1);
            tft.drawString(String(data1), 10, 75);

            if (data1 <= 0) {
              ingresar = false;
            }

            unsigned long t_espera = 5000UL;
            unsigned long start = millis();
            while (millis() - start < t_espera) {
              tft.drawString("READY", 10, 85);
            }
            error_lectura = 0;
            break;
          }
        case 203:
          {
            ingresar = true;
            //Activar el rele cuando se haya leido una tarjeta NFC
            digitalWrite(control, LOW);
            //Serial.println("Rele activado");
            //Serial.println(ingresar);
            tft.drawString("Rele activado : " + String(ingresar), 10, 65);
            error_lectura = 0;
            break;
          }
        default:
          {
            ingresar = false;
            //Serial.println(ingresar);
            tft.drawString(String(ingresar), 10, 65);
            tft.pushImage(110, 25, 64, 64, Notfound);
            tft.drawString("Pulsera no regitrada", 25, 95, 4);
            unsigned long t_espera = 5000UL;
            unsigned long start = millis();
            while (millis() - start < t_espera) {
              tft.drawString("READY", 10, 85);
            }
            error_lectura = 0;
            break;
          }
      }
    } else {

      error_lectura++;
      //*MENSAJE DE ERROR ENVIO DE PETICION DE LA PULSERA
      http.end();
      //Serial.println("Código de respuesta error: " + String(httpCode));
      tft.fillScreen(TFT_BLACK);
      tft.pushImage(110, 25, 64, 64, TryAgain);
      tft.drawString("Coloque nuevamente la pulsera", 15, 95, 2);
      tft.drawString("error: " + String(error_lectura), 10, 120);
      if (error_lectura == 4) {
        HTTPClient http;
        http.begin(apiUrlMant);
        int httpCode = http.GET();
        http.end();

        tft.fillScreen(TFT_BLACK);
        while (true) {
          tft.pushImage(128, 25, 64, 64, imgMant);
          tft.drawString("Maquina en mantenimiento", 5, 95, 4);
          tft.drawString("http: " + String(httpCode), 10, 95);
        }
      }

      unsigned long t_espera = 5000UL;
      unsigned long start = millis();
      while (millis() - start < t_espera) {
        tft.drawString("READY", 10, 85);
      }
    }
  } else {
    // Nensaje de espera para esperar lectura de pulsera
    //Serial.println("Timed out waiting for a card");
    tft.fillScreen(TFT_BLACK);
    tft.pushImage(110, 25, 100, 95, hub);
    tft.drawString("waiting for a card", 10, 10, 4);
  }

  //lazo  de control de estados de la maquina
  while (ingresar) {
    //Serial.println("Loop While");
    tft.fillScreen(TFT_BLACK);
    tft.pushImage(128, 25, 128, 128, beer);
    tft.drawString("Loop While", 10, 10);
    // Realizar una lectura inicial del flujometro para evitar lecturas fantasmas
    frequency = GetFrequency();
    frequency = 0;

    //Switch case para manejar los estados de la maquina
    switch (estado) {

      case 0:
        {
          //Serial.println("CASE 0");
          tft.drawString("CASE 0", 10, 20);
          dt = millis();
          frequency = GetFrequency();
          volumen = getvolume(frequency);

          if (frequency != 0) {
            estadoflujo = true;
            //Serial.println("frecuencia diferente de cero CASE 0");
          } else {
            estadoflujo = false;
            //Serial.println("frecuencia igual a cero, CASE 0");
            estado = 1;
          }
          while (estadoflujo == true && volumen <= data1) {
            dt = millis();
            frequency = GetFrequency();
            //dt = millis();
            volumen = getvolume(frequency);
            //Serial.println(" estadoflujo==true CASE 0");
            if (frequency != 0) {
              estadoflujo = true;
              //Serial.println("frecuencia diferente de cero estado flujo verdadero, CASE 0");
            } else {
              estadoflujo = false;
              //Serial.println("frecuencia igual a cero while estado flujo verdadero, CASE 0");
              estado = 1;
            }
            tft.drawString(String(frequency, 2), 10, 30);
            tft.drawString(String(volumen, 2), 100, 30);
            //            Serial.print(frequency); Serial.println(" HZ");
            //            Serial.print(volumen); Serial.println(" L");
          }

          if (volumen >= data1) {
            estado = 2;
          }

          break;
        }
      case 1:
        {
          tft.drawString("CASE 1", 10, 40);
          //Serial.println("CASE 1");
          while (estadoflujo == false) {
            //Serial.println("WHILE estado flujo == false, CASE 1");
            dt = millis();
            frequency = GetFrequency();
            //dt = millis();
            volumen = getvolume(frequency);
            //Serial.print(frequency); Serial.println(" HZ");

            if (frequency == 0) {

              //Serial.println("caso 1 dentro del while y del if frecuencia 0 ");
              if (tiempoInicioTemporizador == 0) {
                // Inicia el temporizador cuando ingresamos por primera vez al caso 1
                tiempoInicioTemporizador = millis();
              }
              // Calcular el tiempo transcurrido desde que ingresamos al caso 1
              unsigned long tiempoTranscurrido = millis() - tiempoInicioTemporizador;

              tft.drawString(String(tiempoTranscurrido), 10, 50);

              if (tiempoTranscurrido >= interval) {
                //Serial.println("Temporizador de 5 segundos alcanzado. Reiniciando temporizador.");
                tiempoInicioTemporizador = 0;  // Reiniciar el temporizador
                estado = 2;
                estadoflujo = true;
              }

            } else {
              estadoflujo = true;
              //Serial.println("frecuencia diferente a cero while estado flujo verdadero");
              estado = 0;
              tiempoInicioTemporizador = 0;  // Reiniciar el temporizador
            }
            tft.drawString(String(frequency, 2), 10, 60);
            tft.drawString(String(volumen, 2), 100, 60);
            //            Serial.print(frequency); Serial.println(" HZ");
            //            Serial.print(volumen); Serial.println(" L");
          }

          break;
        }
      case 2:
        {
          tft.drawString("CASE 2", 10, 70);
          //Serial.println("caso2");
          digitalWrite(control, HIGH);
          tft.drawString("Rele desactivado", 10, 80);
          //Serial.println("Rele desactivado");

          if (volumen != 0) {
            tft.drawString("volumen: " + String(volumen, 2), 10, 90);
            //Serial.print("volumen: "); Serial.println(volumen);

            //String para concatenar la direccion &total=
            String total = "&total=";

            //Transformar en String el volumen consumido
            String vol = String(volumen , 2);

            //String vol = String(0.5);
            //obtetner el id de la pulsera en STRING
            String cadenaResultado = "";
            for (int i = 0; i < uidLength; i++) {
              cadenaResultado += String(uid[i]);
            }
            //Serial.println(cadenaResultado);

            //String con direccion URL concatenada
            String apiUrlConcatenada = apiUrlVolumen + cadenaResultado + total + vol;
            //Serial.println(apiUrlConcatenada);
            tft.drawString(apiUrlConcatenada, 10, 100);

            //Enviar petición HTTP Get
            HTTPClient http;
            http.begin(apiUrlConcatenada);
            int httpCode = http.GET();

            //tiempo de espera en caso de que la peticion falle
            unsigned long volume_time = millis();
            while (httpCode < 0 && millis() - volume_time < timeApiurlVolumen) {
              int httpCode = http.GET();
              tft.drawString("R: " + String(httpCode), 10, 110);
            }
            //si paso el tiempo de espera colocar la maquina en mantenimiento
            if (millis() - volume_time > timeApiurlVolumen) {
              http.end();
              tft.drawString("prender servidor", 10, 120);
              HTTPClient http;
              http.begin(apiUrlMant);
              int httpCode = http.GET();
              http.end();

              String cadenaResultado = "";
              for (int i = 0; i < uidLength; i++) {
                cadenaResultado += String(uid[i]);
              }
              tft.fillScreen(TFT_BLACK);
              while (true) {
                tft.pushImage(128, 25, 64, 64, imgMant);
                tft.drawString("Maquina en mantenimiento", 5, 95, 4);
                tft.drawString("vol: " + String(volumen), 10, 10);
                tft.drawString("pulsera: " + cadenaResultado, 10, 20);
                tft.drawString("http: " + String(httpCode), 10, 30);
              }
            }

            tft.drawString("R: " + String(httpCode), 10, 110);
            //Serial.println("Código de respuesta: " + String(httpCode));
            String response = http.getString();
            http.end();
            tft.drawString(response, 10, 110);
            //Serial.println(response);

            unsigned long t_espera = 5000UL;
            unsigned long start = millis();
            while (millis() - start < t_espera) {
              tft.drawString("READY", 10, 120 );
            }

            volumen = 0;
            frequency = 0;
            ingresar = false;
            data1 = 0;
          } else {

            unsigned long t_espera = 5000UL;
            unsigned long start = millis();
            while (millis() - start < t_espera) {
              tft.drawString("vol: " + String(volumen), 10, 120 );
            }

            volumen = 0;
            frequency = 0;
            ingresar = false;
            data1 = 0;

          }
          break;
        }
    }
  }
  tft.fillScreen(TFT_BLACK);
  tft.pushImage(110, 25, 100, 95, hub);
  tft.drawString("waiting for a card", 10, 10, 4);
}
